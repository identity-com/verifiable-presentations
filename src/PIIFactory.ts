import * as R from 'ramda';
import * as uuidv4 from 'uuid/v4';
import { VerifiablePresentationManager, ClaimCriteriaMap } from './VerifiablePresentationManager';
import DsrResolver from '@identity.com/dsr';

const { ScopeRequest } = DsrResolver;
/**
 * Get the names of the evidence documents promised by a DSR response
 *
 * EvidenceProofs in a DSR response look like this:
 * "evidenceProofs": [{
 *       "name": "credential-cvc:IdDocument-v2",
 *       "proofs": {
 *         "idDocumentFront": {
 *           "data": "195f9bf62b1a807abe26828c13f29e443169cdc5f60b22b470bfa50eef55a5a4"
 *         }
 *       }
 *    }]
 * For each entry in the list of evidence proofs, extract the actual document names
 * @return {Array<String>}
 */
const evidenceProofsToDSRDocumentNames = (evidenceProofs = []) => R.pipe(
  R.pluck('proofs'),
  R.map(Object.keys),
  R.flatten,
)(evidenceProofs);

/** returns the evidences document names from the provider DSR */
const dsrRequestedDocuments = providerDSR => Object.keys(R.pathOr([], ['payload', 'channels', 'evidences'], providerDSR));
/**
 * Traverse the provided presentation credentials and creates a map of document proofs for each
 * credential identifier
 * @param {Array<Credential>} presentations: an array of credentials
 * @param {Array<String>} requestedDocuments: documents that the DSR asks for
 * @returns {Array}: e.g. {
 * *      name: 'credential-cvc:IdDocument-v2',
 * *      proofs: {
 * *         idDocumentFront: { data: '195f9bf62b1a807abe26828c13f29e443169cdc5f60b22b470bfa50eef55a5a4' },
 * *       }
 * *     }
 */
const evidenceProofsFromCredentials = (presentations, requestedDocuments = []) => presentations
  .map(
    (credential) => {
      const evidenceClaims = R.pathOr([], ['claim', 'document', 'evidences'], credential);
      const filteredEvidenceClaims = R.pick(requestedDocuments, evidenceClaims);
      return { name: credential.identifier, proofs: R.mergeAll(filteredEvidenceClaims) };
    }
  )
  // only return evidence proofs for credentials that require evidence
  .filter(evidenceProofsByCredential => R.not(R.isEmpty(evidenceProofsByCredential.proofs)));

/**
 * Return the list of evidence documents that the DSR response promises
 * @param {Object} dsrResponse
 * @param {Object} providerDSR
 */
const expectedEvidenceProofs = (dsrResponse, providerDSR) => {
  const presentations = dsrResponse.verifiableData.map(R.prop('credential'));
  return evidenceProofsFromCredentials(presentations, dsrRequestedDocuments(providerDSR));
};



/**
 * Add an upload url to an evidence channel, so the client knows where to send the evidence documents.
 * The url will be generated by the client to be unique
 * @param {Function} urlGeneratorFn: A function to generate a unique URL based on the evidence name provided
 * @return {function(*, *): {url: *}}
 */
const addEvidenceUrl = (urlGeneratorFn) => (evidenceChannelConfiguration, evidenceName) => {
  const url = urlGeneratorFn(evidenceName);
  return {
    ...evidenceChannelConfiguration,
    url,
  };
};

export class PIIFactory {
  provider: string;
  providerDSR: object;
  mapping: ClaimCriteriaMap;
  formatters: any;
  constructor(provider, providerDSR, mapping, formatters) {
    this.providerDSR = providerDSR;
    this.provider = provider;
    this.mapping = mapping;
    this.formatters = formatters;
  };

  /**
   * The client is asked for a list of documents that the provider is interested in (requestedDocuments)
   * It returns in the credential, a list of documents that it can provide.
   * Return the intersection between these two, to identify which documents are expected.
   *
   * @param evidenceProofs
   * @return {string[]}
   */
  expectedDocumentsGivenEvidenceProofs(evidenceProofs) {
    const promisedDocuments = evidenceProofsToDSRDocumentNames(evidenceProofs);
    return R.intersection(dsrRequestedDocuments(this.providerDSR), promisedDocuments);
  };

  /**
   * Validate the dsr response, extract the PII, and format it for the provider.
   * @param dsrResponse
   * @return {Promise<{evidenceProofs: *, formattedClaims: *}>}
   */
  async extractPII(dsrResponse) {
    const presentations = dsrResponse.verifiableData.map(R.prop('credential'));
    const evidenceProofs = expectedEvidenceProofs(dsrResponse, this.providerDSR);
    const artifacts = {
      presentations,
      evidences: [],
    };
    try {
      const verifiablePresentation = new VerifiablePresentationManager({
        skipAddVerify: true, skipGetVerify: true, allowGetUnverified: true,
      });
      // this throws an error if the DSR response is invalid
      await verifiablePresentation.addCredentialArtifacts(artifacts);

      // using the credential to provider mapping, get the credentials values
      const mappedClaimValues = await verifiablePresentation.mapClaimValues(this.mapping);

      const formatIfFormatterExists = (value, key) => (value && this.formatters[key] ? this.formatters[key].format(value) : value);
      const formattedClaims = R.mapObjIndexed(formatIfFormatterExists, mappedClaimValues);

      return { formattedClaims, evidenceProofs };
    } catch (error) {
      throw new Error('The dsr response on the requirements is invalid');
    }
  };
  /**
   * Generate a DSR based on the template and evidence functions provided
   * @param {String} eventsURL
   * @param {String} idvDid
   * @param {Object} dsrResolver
   * @param {Function} urlGeneratorFn
   */
  generateDSR(eventsURL, idvDid, dsrResolver, urlGeneratorFn) {

    if (!this.providerDSR) { throw new Error(`Provider ${this.provider} is unknown or does not require a DSR`); }

    const uuid = uuidv4.default();
    const requestedItems = R.pathOr([], ['payload', 'credentialItems'], this.providerDSR);
    // iterate over the requested items array, set the values on the path constraints.meta.issue.is.$eq for the idv value
    const updatedRequestedItems = R.map(R.assocPath((['constraints', 'meta', 'issuer', 'is', '$eq']), idvDid))(requestedItems);

    // add a fresh S3 upload url to each evidence channel, tailored for this user
    const evidenceChannelTemplate = R.pathOr([], ['payload', 'channels', 'evidences'], this.providerDSR);
    const evidences = R.mapObjIndexed(addEvidenceUrl(urlGeneratorFn), evidenceChannelTemplate);

    const channelsConfig = {
      eventsURL,
      evidences,
    };
    const appConfig = R.pathOr([], ['payload', 'requesterInfo', 'app'], this.providerDSR);

    return ScopeRequest.buildSignedRequestBody(new ScopeRequest.ScopeRequest(uuid, updatedRequestedItems, channelsConfig, appConfig, dsrResolver));
  };
}